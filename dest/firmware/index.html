<!doctype html>
<html>
<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width">

  <title>Spark Docs | Firmware reference</title>

  <!-- Flatdoc -->
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>

  <!-- Let me embed vines -->
  <script async src="//platform.vine.co/static/scripts/embed.js" charset="utf-8"></script>

  <!-- Favicon -->
  <link rel="icon" href="../assets/favicon.ico">

  <!-- Flatdoc theme -->
  <link href='../assets/css/theme-white.css' rel='stylesheet'>
  <script src='../assets/js/theme-white.js'></script>

  <!-- Spark theme mods -->
  <link href='../assets/css/style.css' rel='stylesheet'>
  <script src='../assets/js/spark.js'></script>

  <!-- Meta -->
  <meta content="Spark" property="og:title">
  <meta content="Documentation for Spark, a platform for connected devices." name="description">

</head>
<body role='flatdoc'>

  <div id="docs">
    <div class='header'>
      <div class='left'>
        <a href="https://www.spark.io">
          <img src="../assets/images/sparklogo-2x.png" id="logo">
        </a>
      </div>
      <div class='right'>
        <a href="http://www.github.com/spark/docs" class="contribute">Contribute</a>
      </div>
    </div>

    <div class='content-root'>
      <div class='menubar'>
        <div class='menu section' role='flatdoc-menu'>
          <ul>
            
              <li><a href='../start'>Getting started</a></li>
              <ul>
                <!-- TODO: add nested lists for headers/subheaders -->
              </ul>
            
              <li><a href='../connect'>Connecting your Core</a></li>
              <ul>
                <!-- TODO: add nested lists for headers/subheaders -->
              </ul>
            
              <li><a href='../examples'>Annotated examples</a></li>
              <ul>
                <!-- TODO: add nested lists for headers/subheaders -->
              </ul>
            
              <li><a href='../firmware'>Firmware reference</a></li>
              <ul>
                <!-- TODO: add nested lists for headers/subheaders -->
              </ul>
            
              <li><a href='../api'>Cloud API reference</a></li>
              <ul>
                <!-- TODO: add nested lists for headers/subheaders -->
              </ul>
            
              <li><a href='../hardware'>Hardware datasheet</a></li>
              <ul>
                <!-- TODO: add nested lists for headers/subheaders -->
              </ul>
            
              <li><a href='../shields'>Shields and kits</a></li>
              <ul>
                <!-- TODO: add nested lists for headers/subheaders -->
              </ul>
            
          </ul>
        </div>
      </div>
      <div role='flatdoc-content' class='content'>
        <h1 id="spark-core-firmware">Spark Core Firmware</h1>
<h1 id="functions">Functions</h1>
<h2 id="cloud">Cloud</h2>
<h3 id="spark-variable-">Spark.variable()</h3>
<p>Expose a <em>variable</em> through the Spark Cloud so that it can be called with <code>GET /v1/devices/{DEVICE_ID}/{VARIABLE}</code>.</p>
<pre><code class="language-C++">EXAMPLE USAGE
int temperature = 0;

void setup()
{
  Spark.variable(&quot;temperature&quot;, &amp;temperature, INT);
  pinMode(A0, INPUT);
}

void loop()
{
  temperature = analogRead(A0);
}</code></pre>
<p>COMPLEMENTARY API CALL</p>
<pre><code class="language-json"># EXAMPLE REQUEST IN TERMINAL
# Core ID is 0123456789abcdef01234567
# Your access token is 1234123412341234123412341234123412341234
curl &quot;https://api.spark.io/v1/devices/0123456789abcdef01234567/temperature?access_token=1234123412341234123412341234123412341234&quot;</code></pre>
<h3 id="spark-function-">Spark.function()</h3>
<p>Expose a <em>function</em> through the Spark Cloud so that it can be called with <code>POST device/{FUNCTION}</code>.</p>
<p>Currently the application supports the creation of upto 4 different Spark functions.</p>
<pre><code class="language-cpp">SYNTAX TO REGISTER A SPARK FUNCTION
Spark.function(<span class="string">"funcKey"</span>, funcName);
                  ^
                  |
     (max of <span class="number">12</span> characters <span class="keyword">long</span>)</code></pre>
<p>In order to register a Spark function, the user provides the <code>funcKey</code>, which is the string name used to make a POST request and a <code>funcName</code>, which is the actual name of the function that gets called in the Spark app. The Spark function can return any integer; <code>-1</code> is commonly used for a failed function call.</p>
<p>The length of the <code>funcKey</code> is limited to a max of 12 characters.</p>
<p>A Spark function is set up to take one argument of the <a href="http://arduino.cc/en/Reference/StringObject">String</a> datatype. This argument length is limited to a max of 64 characters.</p>
<pre><code class="language-cpp">EXAMPLE USAGE
<span class="keyword">int</span> brewCoffee(String command);

<span class="keyword">void</span> setup()
{
  <span class="comment">//register the Spark function</span>
  Spark.function(<span class="string">"brew"</span>, brewCoffee);
}

<span class="keyword">void</span> loop()
{
  <span class="comment">//this loops forever</span>
}

<span class="comment">//this function automagically gets called upon a matching POST request</span>
<span class="keyword">int</span> brewCoffee(String command)
{
  <span class="comment">//look for the matching argument "coffee" &lt;-- max of 64 characters long</span>
  <span class="keyword">if</span>(command == <span class="string">"coffee"</span>)
  {
    <span class="comment">//do something here</span>
    activateWaterHeater();
    activateWaterPump();
    <span class="keyword">return</span> <span class="number">1</span>;
  }
  <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;
}</code></pre>
<pre><code class="language-json">COMPLEMENTARY API CALL
POST /v1/devices/{DEVICE_ID}/{FUNCTION}

# EXAMPLE REQUEST
curl https://api.spark.io/v1/devices/0123456789abcdef01234567/brew \
     -d access_token=1234123412341234123412341234123412341234 \
     -d &quot;args=coffee&quot;</code></pre>
<p>The API request will be routed to the Spark Core and will run your brew function. The response will have a return_value key containing the integer returned by brew.</p>
<h3 id="spark-event-">Spark.event()</h3>
<p>Send an <em>event</em> through the Spark Cloud that will be forwarded to registered callbacks and server-sent event streams.</p>
<p>This feature will allow the Core to generate an <em>event</em> based on a condition. For example, you could connect a motion sensor to the core and have a the Core generate an event whenever motion is detected. Unlike the Spark variable, you don&#39;t have to send out an API GET request.</p>
<p>This feature is currently under implementation.</p>
<!-- TO DO -->
<!--
```C++
SYNTAX
Spark.event(event_name, event_result);

EXAMPLE USAGE
int motion_sensor = 0;
int sensor_value = 0;

void loop() {
  sensor_value = analogRead(motion_sensor);

  if (sensor_value == 1) {
    Spark.event("motion", "motion detected");
  }
}

COMPLEMENTARY API CALL
I guess this should be callback registration...?
```
-->

<h3 id="spark-connected-">Spark.connected()</h3>
<p>Returns <code>true</code> when connected to the Spark Cloud, and <code>false</code> when disconnected to the Spark Cloud.</p>
<pre><code class="language-C++">SYNTAX
Spark.connected();

RETURNS
boolean (true or false)

EXAMPLE USAGE
void setup() {
  Serial.begin(9600);
}

void loop() {
  if (Spark.connected()) {
    Serial.println(&quot;Connected!&quot;);
  }
  delay(1000);
}</code></pre>
<!-- TO DO
### Spark.disconnect()

Disconnects the Spark Core from the Spark Cloud.

```C++
SYNTAX
Spark.disconnect()

EXAMPLE USAGE
Hmm, not sure what this one should look like...
```

NOTE: When the Core is disconnected, over-the-air updates are no longer possible. To re-enable over-the-air firmware updates, initiate a factory reset.



### Spark.connect()

Re-connects the Spark Core to the Spark Cloud after `Spark.disconnect()` is called.

```C++
SYNTAX
Spark.connect()
```

The Spark Core connects to the cloud by default, so it's not necessary to call `Spark.connect()` unless you have explicitly disconnected the Core.
-->

<!-- TO DO -->
<!-- Add example implementation here -->
<!--
### Spark.print()

Prints to the debug console in Spark's web IDE.
-->

<!-- TO DO -->
<!-- Add example implementation here -->

<!--
### Spark.println()

Prints to the debug console in Spark's web IDE, followed by a *newline* character.
-->
<!-- TO DO -->
<!-- Add example implementation here -->

<h2 id="sleep">Sleep</h2>
<h3 id="spark-sleep-">Spark.sleep()</h3>
<p><code>Spark.sleep()</code> can be used to dramatically improve the battery life of a Spark-powered project by temporarily deactivating the Wi-Fi module, which is by far the biggest power draw.</p>
<pre><code class="language-C++">SYNTAX
Spark.sleep(int seconds);</code></pre>
<pre><code class="language-C++">// EXAMPLE USAGE: Put the Core to sleep for 5 seconds
Spark.sleep(5);
// The Core LED will flash green during sleep</code></pre>
<p><code>Spark.sleep()</code> can also be used to put the entire Core into a <em>deep sleep</em> mode. In this particular mode, the Core shuts down the Wi-Fi chipset (CC3000) and puts the microcontroller in a stand-by mode.</p>
<pre><code class="language-C++">SYNTAX
Spark.sleep(SLEEP_MODE_DEEP, int seconds);</code></pre>
<pre><code class="language-C++">// EXAMPLE USAGE: Put the Core into deep sleep for 60 seconds
Spark.sleep(SLEEP_MODE_DEEP,60);
// The Core LED will shut off during deep sleep</code></pre>
<p>The Core will automatically <em>wake up</em> and reestablish the WiFi connection after the specified number of seconds.</p>
<p>In <em>standard sleep mode</em>, the Core current consumption is in the range of: <strong>15mA to 30mA</strong></p>
<p>In <em>deep sleep mode</em>, the Core current consumption is around: <strong>3.2 μA</strong></p>
<!--
Spark.sleep(int millis, array peripherals);
-->

<!--
`Spark.sleep()` can also take an optional second argument, an `array` of other peripherals to deactivate. Deactivating unused peripherals on the micro-controller can take its power consumption into the micro-amps.
-->

<!-- TO DO -->
<!-- Add example implementation here -->

<h2 id="input-output">Input/Output</h2>
<h3 id="pinmode-">pinMode()</h3>
<p><code>pinMode()</code> configures the specified pin to behave either as an input or an output.</p>
<pre><code class="language-C++">SYNTAX
pinMode(pin,mode);</code></pre>
<p><code>pinMode()</code> takes two arguments, <code>pin</code>: the number of the pin whose mode you wish to set and <code>mode</code>: <code>INPUT, INPUT_PULLUP, INPUT_PULLDOWN or OUTPUT.</code></p>
<p><code>pinMode()</code> does not return anything.</p>
<pre><code class="language-C++">EXAMPLE USAGE
int button = D0;                       // button is connected to D0
int LED = D1;                          // LED is connected to D1

void setup()
{
  pinMode(LED, OUTPUT);               // sets pin as output
  pinMode(button, INPUT_PULLDOWN);    // sets pin as input
}

void loop()
{
  while(digitalRead(button) == HIGH)  // blink the LED as long as the button is pressed
  {
    digitalWrite(LED, HIGH);          // sets the LED on
    delay(200);                       // waits for 200mS
    digitalWrite(LED, LOW);           // sets the LED off
    delay(200);                       // waits for 200mS
  }
}</code></pre>
<h3 id="digitalwrite-">digitalWrite()</h3>
<p>Write a <code>HIGH</code> or a <code>LOW</code> value to a digital pin.</p>
<pre><code class="language-C++">SYNTAX
digitalWrite(pin, value);</code></pre>
<p>If the pin has been configured as an OUTPUT with pinMode(), its voltage will be set to the corresponding value: 3.3V for HIGH, 0V (ground) for LOW.</p>
<p><code>digitalWrite()</code> takes two arguments, <code>pin</code>: the number of the pin whose value you wish to set and <code>value</code>: <code>HIGH</code> or <code>LOW</code>.</p>
<p><code>digitalWrite()</code> does not return anything.</p>
<pre><code class="language-C++">EXAMPLE USAGE
int LED = D1;                       // LED is connected to D1

void setup()
{
  pinMode(LED, OUTPUT);             // sets pin as output
}

void loop()
{
  digitalWrite(LED, HIGH);          // sets the LED on
  delay(200);                       // waits for 200mS
  digitalWrite(LED, LOW);           // sets the LED off
  delay(200);                       // waits for 200mS
}</code></pre>
<h3 id="digitalread-">digitalRead()</h3>
<p>Reads the value from a specified digital <code>pin</code>, either <code>HIGH</code> or <code>LOW</code>.</p>
<pre><code class="language-C++">SYNTAX
digitalRead(pin);</code></pre>
<p><code>digitalRead()</code> takes one argument, <code>pin</code>: the number of the digital pin you want to read.</p>
<p><code>digitalRead()</code> returns <code>HIGH</code> or <code>LOW</code>.</p>
<pre><code class="language-C++">EXAMPLE USAGE
int button = D0;                       // button is connected to D0
int LED = D1;                          // LED is connected to D1
int val = 0;                           // variable to store the read value

void setup()
{
  pinMode(LED, OUTPUT);               // sets pin as output
  pinMode(button, INPUT_PULLDOWN);    // sets pin as input
}

void loop()
{
  val = digitalRead(button);          // read the input pin
  digitalWrite(LED, val);             // sets the LED to the button&#39;s value
}</code></pre>
<h3 id="analogwrite-">analogWrite()</h3>
<p>Writes an analog value (PWM wave) to a pin. Can be used to light a LED at varying brightnesses or drive a motor at various speeds. After a call to analogWrite(), the pin will generate a steady square wave of the specified duty cycle until the next call to analogWrite() (or a call to digitalRead() or digitalWrite() on the same pin). The frequency of the PWM signal is approximately 500 Hz.</p>
<p>On the Spark Core, this function works on pins A0, A1, A4, A5, A6, A7, D0 and D1.</p>
<p>The analogWrite function has nothing to do with the analog pins or the analogRead function.</p>
<pre><code class="language-C++">SYNTAX
analogWrite(pin, value);</code></pre>
<p><code>analogWrite()</code> takes two arguments, <code>pin</code>: the number of the pin whose value you wish to set and <code>value</code>: the duty cycle: between 0 (always off) and 255 (always on).</p>
<p><code>analogWrite()</code> does not return anything.</p>
<pre><code class="language-C++">EXAMPLE USAGE
int ledPin = D1;                // LED connected to digital pin D1
int analogPin = A0;             // potentiometer connected to analog pin A0
int val = 0;                    // variable to store the read value

void setup()
{
  pinMode(ledPin, OUTPUT);      // sets the pin as output
}

void loop()
{
  val = analogRead(analogPin);  // read the input pin
  analogWrite(ledPin, val/16);  // analogRead values go from 0 to 4095, analogWrite values from 0 to 255
  delay(10);
}</code></pre>
<h3 id="analogread-">analogRead()</h3>
<p>Reads the value from the specified analog pin. The Spark Core has 8 channels (A0 to A7) with a 12-bit resolution. This means that it will map input voltages between 0 and 3.3 volts into integer values between 0 and 4095. This yields a resolution between readings of: 3.3 volts / 4096 units or, 0.0008 volts (0.8 mV) per unit.</p>
<pre><code class="language-C++">SYNTAX
analogRead(pin);</code></pre>
<p><code>analogRead()</code> takes one argument <code>pin</code>: the number of the analog input pin to read from (&#39;A0 to A7&#39;.)</p>
<p><code>analogRead()</code> returns an integer value ranging from 0 to 4095.</p>
<pre><code class="language-C++">EXAMPLE USAGE
int ledPin = D1;                // LED connected to digital pin D1
int analogPin = A0;             // potentiometer connected to analog pin A0
int val = 0;                    // variable to store the read value

void setup()
{
  pinMode(ledPin, OUTPUT);      // sets the pin as output
}

void loop()
{
  val = analogRead(analogPin);  // read the input pin
  analogWrite(ledPin, val/16);  // analogRead values go from 0 to 4095, analogWrite values from 0 to 255
  delay(10);
}</code></pre>
<h1 id="communication">Communication</h1>
<h2 id="serial">Serial</h2>
<p>Used for communication between the Spark Core and a computer or other devices. The Core has two serial channels:  </p>
<p><code>Serial:</code> This channel communicates through the USB port and when connected to a computer, will show up as a virtual COM port.  </p>
<p><code>Serial1:</code> This channel is available via the Core&#39;s TX and RX pins. To use these pins to communicate with your personal computer, you will need an additional USB-to-serial adapter. To use them to communicate with an external TTL serial device, connect the TX pin to your device&#39;s RX pin, the RX to your device&#39;s TX pin, and the ground of your Core to your device&#39;s ground.</p>
<p><strong>NOTE:</strong> Please take into account that the voltage levels on these pins runs at 0V to 3.3V and should not be connected directly to a computer&#39;s RS232 serial port which operates at +/- 12V and can damage the Core.</p>
<h3 id="begin-">begin()</h3>
<p>Sets the data rate in bits per second (baud) for serial data transmission. For communicating with the computer, use one of these rates: 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, or 115200. You can, however, specify other rates - for example, to communicate over pins TX and RX with a component that requires a particular baud rate.</p>
<pre><code class="language-C++">SYNTAX
Serial.begin(speed);    // serial via USB port
Serial1.begin(speed);   // serial via TX and RX pins</code></pre>
<p><code>speed</code>: parameter that specifies the baud rate <em>(long)</em></p>
<p><code>begin()</code> does not return anything</p>
<pre><code class="language-C++">EXAMPLE USAGE
void setup()
{
  Serial.begin(9600);   // open serial over USB
  Serial1.begin(9600);  // open serial over TX and RX pins

  Serial.println(&quot;Hello Computer&quot;);
  Serial1.println(&quot;Hello Serial 1&quot;);
}

void loop() {}</code></pre>
<h3 id="end-">end()</h3>
<p>Disables serial communication, allowing the RX and TX pins to be used for general input and output. To re-enable serial communication, call <code>Serial1.begin()</code>.</p>
<pre><code class="language-C++">SYNTAX
Serial1.end();</code></pre>
<h3 id="available-">available()</h3>
<p>Get the number of bytes (characters) available for reading from the serial port. This is data that&#39;s already arrived and stored in the serial receive buffer (which holds 64 bytes).</p>
<pre><code class="language-C++">EXAMPLE USAGE
void setup()
{
  Serial.begin(9600);
  Serial1.begin(9600);

}

void loop()
{
  // read from port 0, send to port 1:
  if (Serial.available())
  {
    int inByte = Serial.read();
    Serial1.print(inByte, BYTE);
  }
  // read from port 1, send to port 0:
  if (Serial1.available())
  {
    int inByte = Serial1.read();
    Serial.print(inByte, BYTE);
  }
}</code></pre>
<h3 id="peek-">peek()</h3>
<p>Returns the next byte (character) of incoming serial data without removing it from the internal serial buffer. That is, successive calls to peek() will return the same character, as will the next call to <code>read()</code>.</p>
<pre><code class="language-C++">SYNTAX
Serial.peek();
Serial1.peek();</code></pre>
<p><code>peek()</code> returns the first byte of incoming serial data available (or <code>-1</code> if no data is available) - <em>int</em></p>
<h3 id="write-">write()</h3>
<p>Writes binary data to the serial port. This data is sent as a byte or series of bytes; to send the characters representing the digits of a number use the <code>print()</code> function instead.</p>
<pre><code class="language-C++">SYNTAX
Serial.write(val);
Serial.write(str);
Serial.write(buf, len);</code></pre>
<p><em>Parameters:</em></p>
<ul>
<li><code>val</code>: a value to send as a single byte</li>
<li><code>str</code>: a string to send as a series of bytes</li>
<li><code>buf</code>: an array to send as a series of bytes</li>
<li><code>len</code>: the length of the buffer</li>
</ul>
<p><code>write()</code> will return the number of bytes written, though reading that number is optional.</p>
<pre><code class="language-C++">EXAMPLE USAGE
void setup()
{
  Serial.begin(9600);
}

void loop()
{
  Serial.write(45); // send a byte with the value 45

   int bytesSent = Serial.write(“hello”); //send the string “hello” and return the length of the string.
}</code></pre>
<h3 id="read-">read()</h3>
<p>Reads incoming serial data.</p>
<pre><code class="language-C++">SYNTAX
Serial.read();
Serial1.read();</code></pre>
<p><code>read()</code> returns the first byte of incoming serial data available (or -1 if no data is available) - <em>int</em></p>
<pre><code class="language-C++">EXAMPLE USAGE
int incomingByte = 0;   // for incoming serial data

void setup() {
        Serial.begin(9600);     // opens serial port, sets data rate to 9600 bps
}

void loop() {

        // send data only when you receive data:
        if (Serial.available() &gt; 0) {
                // read the incoming byte:
                incomingByte = Serial.read();

                // say what you got:
                Serial.print(&quot;I received: &quot;);
                Serial.println(incomingByte, DEC);
        }
}</code></pre>
<h3 id="print-">print()</h3>
<p>Prints data to the serial port as human-readable ASCII text. This command can take many forms. Numbers are printed using an ASCII character for each digit. Floats are similarly printed as ASCII digits, defaulting to two decimal places. Bytes are sent as a single character. Characters and strings are sent as is. For example:</p>
<ul>
<li>Serial.print(78) gives &quot;78&quot;</li>
<li>Serial.print(1.23456) gives &quot;1.23&quot;</li>
<li>Serial.print(&#39;N&#39;) gives &quot;N&quot;</li>
<li>Serial.print(&quot;Hello world.&quot;) gives &quot;Hello world.&quot;</li>
</ul>
<p>An optional second parameter specifies the base (format) to use; permitted values are BIN (binary, or base 2), OCT (octal, or base 8), DEC (decimal, or base 10), HEX (hexadecimal, or base 16). For floating point numbers, this parameter specifies the number of decimal places to use. For example:</p>
<ul>
<li>Serial.print(78, BIN) gives &quot;1001110&quot;</li>
<li>Serial.print(78, OCT) gives &quot;116&quot;</li>
<li>Serial.print(78, DEC) gives &quot;78&quot;</li>
<li>Serial.print(78, HEX) gives &quot;4E&quot;</li>
<li>Serial.println(1.23456, 0) gives &quot;1&quot;</li>
<li>Serial.println(1.23456, 2) gives &quot;1.23&quot;</li>
<li>Serial.println(1.23456, 4) gives &quot;1.2346&quot;</li>
</ul>
<h3 id="println-">println()</h3>
<p>Prints data to the serial port as human-readable ASCII text followed by a carriage return character (ASCII 13, or &#39;\r&#39;) and a newline character (ASCII 10, or &#39;\n&#39;). This command takes the same forms as <code>Serial.print()</code>.</p>
<pre><code class="language-C++">SYNTAX
Serial.println(val);
Serial.println(val, format);</code></pre>
<p><em>Parameters:</em>  </p>
<ul>
<li><code>val</code>: the value to print - any data type</li>
<li><code>format</code>: specifies the number base (for integral data types) or number of decimal places (for floating point types)</li>
</ul>
<p><code>println()</code> returns the number of bytes written, though reading that number is optional - <code>size_t (long)</code></p>
<pre><code class="language-C++">EXAMPLE
//reads an analog input on analog in A0, prints the value out.

int analogValue = 0;    // variable to hold the analog value

void setup()
{
  // open the serial port at 9600 bps:
  Serial.begin(9600);
}

void loop() {
  // read the analog input on pin A0:
  analogValue = analogRead(A0);

  // print it out in many formats:
  Serial.println(analogValue);       // print as an ASCII-encoded decimal
  Serial.println(analogValue, DEC);  // print as an ASCII-encoded decimal
  Serial.println(analogValue, HEX);  // print as an ASCII-encoded hexadecimal
  Serial.println(analogValue, OCT);  // print as an ASCII-encoded octal
  Serial.println(analogValue, BIN);  // print as an ASCII-encoded binary

  // delay 10 milliseconds before the next reading:
  delay(10);
}</code></pre>
<h3 id="flush-">flush()</h3>
<p>Waits for the transmission of outgoing serial data to complete.</p>
<pre><code class="language-C++">SYNTAX
Serial.flush();
Serial1.flush();</code></pre>
<p><code>flush()</code> neither takes a parameter nor returns anything</p>
<h2 id="spi">SPI</h2>
<p>This library allows you to communicate with SPI devices, with the Spark Core as the master device.</p>
<p><img src="images/core-pin-spi.jpg" alt="SPI"></p>
<h3 id="begin-">begin()</h3>
<p>Initializes the SPI bus by setting SCK, MOSI, and SS to outputs, pulling SCK and MOSI low, and SS high.</p>
<p>Note that once the pin is configured, you can&#39;t use it anymore as a general I/O, unless you call the SPI.end() method on the same pin.</p>
<pre><code class="language-C++">// SYNTAX
SPI.begin();</code></pre>
<h3 id="end-">end()</h3>
<p>Disables the SPI bus (leaving pin modes unchanged).</p>
<pre><code class="language-C++">// SYNTAX
SPI.end();</code></pre>
<h3 id="setbitorder-">setBitOrder()</h3>
<p>Sets the order of the bits shifted out of and into the SPI bus, either LSBFIRST (least-significant bit first) or MSBFIRST (most-significant bit first).</p>
<pre><code class="language-C++">// SYNTAX
SPI.setBitOrder(order);</code></pre>
<p>Where, the parameter <code>order</code> can either be <code>LSBFIRST</code> or <code>MSBFIRST</code>.</p>
<h3 id="setclockdivider-">setClockDivider()</h3>
<p>Sets the SPI clock divider relative to the system clock. The available dividers  are 2, 4, 8, 16, 32, 64, 128 or 256. The default setting is SPI_CLOCK_DIV4, which sets the SPI clock to one-quarter the frequency of the system clock.</p>
<pre><code class="language-C++">// SYNTAX
SPI.setClockDivider(divider) ;</code></pre>
<p>Where the parameter, <code>divider</code> can be:</p>
<pre><code>SPI_CLOCK_DIV2
SPI_CLOCK_DIV4
SPI_CLOCK_DIV8
SPI_CLOCK_DIV16
SPI_CLOCK_DIV32
SPI_CLOCK_DIV64
SPI_CLOCK_DIV128
SPI_CLOCK_DIV256</code></pre>
<h3 id="setdatamode-">setDataMode()</h3>
<p>Sets the SPI data mode: that is, clock polarity and phase. See the <a href="http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus">Wikipedia article on SPI</a> for details.</p>
<pre><code class="language-C++">// SYNTAX
SPI.setClockDivider(mode) ;</code></pre>
<p>Where the parameter, <code>mode</code> can be:</p>
<pre><code>SPI_MODE0
SPI_MODE1
SPI_MODE2
SPI_MODE3</code></pre>
<h3 id="transfer-">transfer()</h3>
<p>Transfers one byte over the SPI bus, both sending and receiving.</p>
<pre><code class="language-C++">// SYNTAX
SPI.transfer(val);</code></pre>
<p>Where the parameter <code>val</code>, can is the byte to send out over the SPI bus.</p>
<h2 id="wire">Wire</h2>
<p><img src="images/core-pin-i2c.jpg" alt="I2C"></p>
<p>This library allows you to communicate with I2C / TWI devices. On the Spark Core, D0 is the Serial Data Line (SDA) and D1 is the Serial Clock (SCL). Both of these pins runs at 3.3V logic but are tolerant to 5V.</p>
<h3 id="begin-">begin()</h3>
<p>Initiate the Wire library and join the I2C bus as a master or slave. This should normally be called only once.</p>
<pre><code class="language-C++">// SYNTAX
Wire.begin();
Wire.begin(address);</code></pre>
<p>Parameters: <code>address</code>: the 7-bit slave address (optional); if not specified, join the bus as a master.</p>
<h3 id="requestfrom-">requestFrom()</h3>
<p>Used by the master to request bytes from a slave device. The bytes may then be retrieved with the <code>available()</code> and <code>read()</code> functions.</p>
<p>If true, requestFrom() sends a stop message after the request, releasing the I2C bus.</p>
<p>If false, requestFrom() sends a restart message after the request. The bus will not be released, which prevents another master device from requesting between messages. This allows one master device to send multiple requests while in control.</p>
<p>The default value is true.</p>
<pre><code class="language-C++">// SYNTAX
Wire.requestFrom(address, quantity);
Wire.requestFrom(address, quantity, stop) ;</code></pre>
<p>Parameters:</p>
<ul>
<li><code>address</code>: the 7-bit address of the device to request bytes from</li>
<li><code>quantity</code>: the number of bytes to request</li>
<li><code>stop</code>: boolean. true will send a stop message after the request, releasing the bus. false will continually send a restart after the request, keeping the connection active.</li>
</ul>
<p>Returns: <code>byte</code> : the number of bytes returned from the slave device.</p>
<h3 id="begintransmission-">beginTransmission()</h3>
<p>Begin a transmission to the I2C slave device with the given address. Subsequently, queue bytes for transmission with the <code>write()</code> function and transmit them by calling <code>endTransmission()</code>.</p>
<pre><code class="language-C++">// SYNTAX
Wire.beginTransmission(address);</code></pre>
<p>Parameters: <code>address</code>: the 7-bit address of the device to transmit to.</p>
<h3 id="endtransmission-">endTransmission()</h3>
<p>Ends a transmission to a slave device that was begun by <code>beginTransmission()</code> and transmits the bytes that were queued by <code>write()</code>.</p>
<p>If true, <code>endTransmission()</code> sends a stop message after transmission, releasing the I2C bus.</p>
<p>If false, <code>endTransmission()</code> sends a restart message after transmission. The bus will not be released, which prevents another master device from transmitting between messages. This allows one master device to send multiple transmissions while in control.</p>
<p>The default value is true.</p>
<pre><code class="language-C++">Wire.endTransmission();
Wire.endTransmission(stop);</code></pre>
<p>Parameters: <code>stop</code> : boolean.<br><code>true</code> will send a stop message, releasing the bus after transmission. <code>false</code> will send a restart, keeping the connection active.</p>
<p>Returns: <code>byte</code>, which indicates the status of the transmission:</p>
<ul>
<li>0: success</li>
<li>1: data too long to fit in transmit buffer</li>
<li>2: received NACK on transmit of address</li>
<li>3: received NACK on transmit of data</li>
<li>4: other error</li>
</ul>
<h3 id="write-">write()</h3>
<p>Writes data from a slave device in response to a request from a master, or queues bytes for transmission from a master to slave device (in-between calls to <code>beginTransmission()</code> and <code>endTransmission()</code>).</p>
<pre><code class="language-C++">// Syntax
Wire.write(value);
Wire.write(string);
Wire.write(data, length);</code></pre>
<p>Parameters:</p>
<ul>
<li><code>value</code>: a value to send as a single byte</li>
<li><code>string</code>: a string to send as a series of bytes</li>
<li><code>data</code>: an array of data to send as bytes</li>
<li><code>length</code>: the number of bytes to transmit</li>
</ul>
<p>Returns:  <code>byte</code>  </p>
<p><code>write()</code> will return the number of bytes written, though reading that number is optional.</p>
<pre><code class="language-C++">// EXAMPLE USAGE
byte val = 0;

void setup()
{
  Wire.begin(); // join i2c bus
}

void loop()
{
  Wire.beginTransmission(44); // transmit to device #44 (0x2c)
                              // device address is specified in datasheet
  Wire.write(val);             // sends value byte  
  Wire.endTransmission();     // stop transmitting

  val++;        // increment value
  if(val == 64) // if reached 64th position (max)
  {
    val = 0;    // start over from lowest value
  }
  delay(500);
}</code></pre>
<h3 id="available-">available()</h3>
<p>Returns the number of bytes available for retrieval with <code>read()</code>. This should be called on a master device after a call to <code>requestFrom()</code> or on a slave inside the <code>onReceive()</code> handler.</p>
<pre><code class="language-C++">Wire.available();</code></pre>
<p>Returns: The number of bytes available for reading.</p>
<h3 id="read-">read()</h3>
<p>Reads a byte that was transmitted from a slave device to a master after a call to <code>requestFrom()</code> or was transmitted from a master to a slave. <code>read()</code> inherits from the <code>Stream</code> utility class.</p>
<pre><code class="language-C++">Wire.read() ;</code></pre>
<p>Returns: The next byte received</p>
<pre><code class="language-C++">// EXAMPLE USAGE

void setup()
{
  Wire.begin();        // join i2c bus (address optional for master)
  Serial.begin(9600);  // start serial for output
}

void loop()
{
  Wire.requestFrom(2, 6);    // request 6 bytes from slave device #2

  while(Wire.available())    // slave may send less than requested
  {
    char c = Wire.read();    // receive a byte as character
    Serial.print(c);         // print the character
  }

  delay(500);
}</code></pre>
<h3 id="onreceive-">onReceive()</h3>
<p>Registers a function to be called when a slave device receives a transmission from a master.</p>
<p>Parameters: <code>handler</code>: the function to be called when the slave receives data; this should take a single int parameter (the number of bytes read from the master) and return nothing, e.g.: <code>void myHandler(int numBytes)</code></p>
<h3 id="onrequest-">onRequest()</h3>
<p>Register a function to be called when a master requests data from this slave device.</p>
<p>Parameters: <code>handler</code>: the function to be called, takes no parameters and returns nothing, e.g.: <code>void myHandler()</code></p>
<h2 id="tcpserver">TCPServer</h2>
<h3 id="tcpserver">TCPServer</h3>
<p>Create a server that listens for incoming connections on the specified port.</p>
<pre><code class="language-C++">// SYNTAX
TCPServer server = TCPServer(port);</code></pre>
<p>Parameters: <code>port</code>: the port to listen on (<code>int</code>)</p>
<pre><code class="language-C++">// EXAMPLE USAGE

// telnet defaults to port 23
TCPServer server = TCPServer(23);

void setup()
{
    // start listening for clients
    server.begin();

    Serial.begin(9600);

    delay(1000);

    Serial.println(Network.localIP());
    Serial.println(Network.subnetMask());
    Serial.println(Network.gatewayIP());
    Serial.println(Network.SSID());
}

void loop()
{
  // if an incoming client connects, there will be bytes available to read:
  TCPClient client = server.available();
  if (client == true)
  {
      // read bytes from the incoming client and write them back
      // to any clients connected to the server:
      server.write(client.read());
  }
}</code></pre>
<h3 id="begin-">begin()</h3>
<p>Tells the server to begin listening for incoming connections.</p>
<pre><code class="language-C++">// SYNTAX
server.begin();</code></pre>
<h3 id="available-">available()</h3>
<p>Gets a client that is connected to the server and has data available for reading. The connection persists when the returned client object goes out of scope; you can close it by calling <code>client.stop()</code>.</p>
<p><code>available()</code> inherits from the <code>Stream</code> utility class.</p>
<h3 id="write-">write()</h3>
<p>Write data to all the clients connected to a server. This data is sent as a byte or series of bytes.</p>
<pre><code class="language-C++">// Syntax
server.write(val);
server.write(buf, len);</code></pre>
<p>Parameters:</p>
<ul>
<li><code>val</code>: a value to send as a single byte (byte or char)</li>
<li><code>buf</code>: an array to send as a series of bytes (byte or char)</li>
<li><code>len</code>: the length of the buffer</li>
</ul>
<p>Returns: <code>byte</code>: <code>write()</code> returns the number of bytes written. It is not necessary to read this.</p>
<h3 id="print-">print()</h3>
<p>Print data to all the clients connected to a server. Prints numbers as a sequence of digits, each an ASCII character (e.g. the number 123 is sent as the three characters &#39;1&#39;, &#39;2&#39;, &#39;3&#39;).</p>
<pre><code class="language-C++">// Syntax
server.print(data);
server.print(data, BASE) ;</code></pre>
<p>Parameters:</p>
<ul>
<li><code>data</code>: the data to print (char, byte, int, long, or string)</li>
<li><code>BASE</code>(optional): the base in which to print numbers: BIN for binary (base 2), DEC for decimal (base 10), OCT for octal (base 8), HEX for hexadecimal (base 16).</li>
</ul>
<p>Returns:  <code>byte</code>:  <code>print()</code> will return the number of bytes written, though reading that number is optional</p>
<h3 id="println-">println()</h3>
<p>Print data, followed by a newline, to all the clients connected to a server. Prints numbers as a sequence of digits, each an ASCII character (e.g. the number 123 is sent as the three characters &#39;1&#39;, &#39;2&#39;, &#39;3&#39;).</p>
<pre><code class="language-C++">// Syntax

server.println();
server.println(data);
server.println(data, BASE) ;</code></pre>
<p>Parameters:</p>
<ul>
<li><code>data</code> (optional): the data to print (char, byte, int, long, or string)</li>
<li><code>BASE</code> (optional): the base in which to print numbers: BIN for binary (base 2), DEC for decimal (base 10), OCT for octal (base 8), HEX for hexadecimal (base 16).</li>
</ul>
<h2 id="tcpclient">TCPClient</h2>
<h3 id="tcpclient">TCPClient</h3>
<p>Creates a client which can connect to a specified internet IP address and port (defined in the <code>client.connect()</code> function).</p>
<pre><code class="language-C++">// SYNTAX
TCPClient client;</code></pre>
<pre><code class="language-C++">// EXAMPLE USAGE

TCPClient client;
byte server[] = { 74, 125, 224, 72 }; // Google
void setup()
{
  Serial.begin(9600);
  delay(1000);
  Serial.println(&quot;connecting...&quot;);

  if (client.connect(server, 80))
  {
    Serial.println(&quot;connected&quot;);
    client.println(&quot;GET /search?q=unicorn HTTP/1.0&quot;);
    client.println();
  }
  else
  {
    Serial.println(&quot;connection failed&quot;);
  }
}

void loop()
{
  if (client.available())
  {
    char c = client.read();
    Serial.print(c);
  }

  if (!client.connected())
  {
    Serial.println();
    Serial.println(&quot;disconnecting.&quot;);
    client.stop();
    for(;;)
      ;
  }
}</code></pre>
<h3 id="connected-">connected()</h3>
<p>Whether or not the client is connected. Note that a client is considered connected if the connection has been closed but there is still unread data.</p>
<pre><code class="language-C++">// SYNTAX
client.connected();</code></pre>
<p>Returns true if the client is connected, false if not.</p>
<h3 id="connect-">connect()</h3>
<p>Connects to a specified IP address and port. The return value indicates success or failure. Also supports DNS lookups when using a domain name.</p>
<pre><code class="language-C++">// SYNTAX

client.connect();
client.connect(ip, port);
client.connect(URL, port);</code></pre>
<p>Parameters:</p>
<ul>
<li><code>ip</code>: the IP address that the client will connect to (array of 4 bytes)</li>
<li><code>URL</code>: the domain name the client will connect to (string, ex.:&quot;spark.io&quot;)</li>
<li><code>port</code>: the port that the client will connect to (<code>int</code>)</li>
</ul>
<p>Returns true if the connection succeeds, false if not.</p>
<h3 id="write-">write()</h3>
<p>Write data to the server the client is connected to. This data is sent as a byte or series of bytes.</p>
<pre><code class="language-C++">// SYNTAX
client.write(val);
client.write(buf, len);</code></pre>
<p>Parameters:</p>
<ul>
<li><code>val</code>: a value to send as a single byte (byte or char)</li>
<li><code>buf</code>: an array to send as a series of bytes (byte or char)</li>
<li><code>len</code>: the length of the buffer</li>
</ul>
<p>Returns: <code>byte</code>: <code>write()</code> returns the number of bytes written. It is not necessary to read this value.</p>
<h3 id="print-">print()</h3>
<p>Print data to the server that a client is connected to. Prints numbers as a sequence of digits, each an ASCII character (e.g. the number 123 is sent as the three characters &#39;1&#39;, &#39;2&#39;, &#39;3&#39;).</p>
<pre><code class="language-C++">// Syntax
client.print(data);
client.print(data, BASE) ;</code></pre>
<p>Parameters:</p>
<ul>
<li><code>data</code>: the data to print (char, byte, int, long, or string)</li>
<li><code>BASE</code>(optional): the base in which to print numbers: BIN for binary (base 2), DEC for decimal (base 10), OCT for octal (base 8), HEX for hexadecimal (base 16).</li>
</ul>
<p>Returns:  <code>byte</code>:  <code>print()</code> will return the number of bytes written, though reading that number is optional</p>
<h3 id="println-">println()</h3>
<p>Print data, followed by a carriage return and newline, to the server a client is connected to. Prints numbers as a sequence of digits, each an ASCII character (e.g. the number 123 is sent as the three characters &#39;1&#39;, &#39;2&#39;, &#39;3&#39;).</p>
<pre><code class="language-C++">// Syntax

client.println();
client.println(data);
client.println(data, BASE) ;</code></pre>
<p>Parameters:</p>
<ul>
<li><code>data</code> (optional): the data to print (char, byte, int, long, or string)</li>
<li><code>BASE</code> (optional): the base in which to print numbers: BIN for binary (base 2), DEC for decimal (base 10), OCT for octal (base 8), HEX for hexadecimal (base 16).</li>
</ul>
<h3 id="available-">available()</h3>
<p>Returns the number of bytes available for reading (that is, the amount of data that has been written to the client by the server it is connected to).</p>
<pre><code class="language-C++">// SYNTAX
client.available();</code></pre>
<p>Returns the number of bytes available.</p>
<h3 id="read-">read()</h3>
<p>Read the next byte received from the server the client is connected to (after the last call to <code>read()</code>).</p>
<pre><code class="language-C++">// SYNTAX
client.read();</code></pre>
<p>Returns the next byte (or character), or -1 if none is available.</p>
<h3 id="flush-">flush()</h3>
<p>Discard any bytes that have been written to the client but not yet read.</p>
<pre><code class="language-C++">// SYNTAX
client.flush();</code></pre>
<h3 id="stop-">stop()</h3>
<p>Disconnect from the server.</p>
<pre><code class="language-C++">// SYNTAX
client.stop();</code></pre>
<h2 id="udp">UDP</h2>
<h3 id="udp">UDP</h3>
<h3 id="begin-">begin()</h3>
<h3 id="available-">available()</h3>
<h3 id="beginpacket-">beginPacket()</h3>
<h3 id="endpacket-">endPacket()</h3>
<h3 id="write-">write()</h3>
<h3 id="parsepacket-">parsePacket()</h3>
<h3 id="peek-">peek()</h3>
<h3 id="read-">read()</h3>
<h3 id="flush-">flush()</h3>
<h3 id="stop-">stop()</h3>
<h3 id="remoteip-">remoteIP()</h3>
<h3 id="remoteport-">remotePort()</h3>
<h1 id="libraries">Libraries</h1>
<h2 id="servo">Servo</h2>
<p>This library allows a Spark Core to control RC (hobby) servo motors. Servos have integrated gears and a shaft that can be precisely controlled. Standard servos allow the shaft to be positioned at various angles, usually between 0 and 180 degrees. Continuous rotation servos allow the rotation of the shaft to be set to various speeds.</p>
<pre><code class="language-cpp"><span class="comment">// EXAMPLE CODE</span>

Servo myservo;  <span class="comment">// create servo object to control a servo</span>
                <span class="comment">// a maximum of eight servo objects can be created</span>

<span class="keyword">int</span> pos = <span class="number">0</span>;    <span class="comment">// variable to store the servo position</span>

<span class="keyword">void</span> setup()
{
  myservo.attach(A0);  <span class="comment">// attaches the servo on the A0 pin to the servo object</span>
}


<span class="keyword">void</span> loop()
{
  <span class="keyword">for</span>(pos = <span class="number">0</span>; pos &lt; <span class="number">180</span>; pos += <span class="number">1</span>)  <span class="comment">// goes from 0 degrees to 180 degrees</span>
  {                                  <span class="comment">// in steps of 1 degree</span>
    myservo.write(pos);              <span class="comment">// tell servo to go to position in variable 'pos'</span>
    delay(<span class="number">15</span>);                       <span class="comment">// waits 15ms for the servo to reach the position</span>
  }
  <span class="keyword">for</span>(pos = <span class="number">180</span>; pos&gt;=<span class="number">1</span>; pos-=<span class="number">1</span>)     <span class="comment">// goes from 180 degrees to 0 degrees</span>
  {
    myservo.write(pos);              <span class="comment">// tell servo to go to position in variable 'pos'</span>
    delay(<span class="number">15</span>);                       <span class="comment">// waits 15ms for the servo to reach the position</span>
  }
}</code></pre>
<p>NOTE: Unlike Arduino, you do not need to include <code>Servo.h</code>; it is included automatically.</p>
<h3 id="attach-">attach()</h3>
<p>Set up a servo on a particular pin. Note that, on the Spark Core, Servo can only be attached to pins with a timer (A0, A1, A4, A5, A6, A7, D0, and D1).</p>
<pre><code class="language-cpp"><span class="comment">// SYNTAX</span>
servo.attach(pin)</code></pre>
<h3 id="write-">write()</h3>
<p>Writes a value to the servo, controlling the shaft accordingly. On a standard servo, this will set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous rotation servo, this will set the speed of the servo (with 0 being full-speed in one direction, 180 being full speed in the other, and a value near 90 being no movement).</p>
<pre><code class="language-cpp"><span class="comment">// SYNTAX</span>
servo.write(angle)</code></pre>
<h3 id="writemicroseconds-">writeMicroseconds()</h3>
<p>Writes a value in microseconds (uS) to the servo, controlling the shaft accordingly. On a standard servo, this will set the angle of the shaft. On standard servos a parameter value of 1000 is fully counter-clockwise, 2000 is fully clockwise, and 1500 is in the middle.</p>
<pre><code class="language-cpp"><span class="comment">// SYNTAX</span>
servo.writeMicroseconds(uS)</code></pre>
<p>Note that some manufactures do not follow this standard very closely so that servos often respond to values between 700 and 2300. Feel free to increase these endpoints until the servo no longer continues to increase its range. Note however that attempting to drive a servo past its endpoints (often indicated by a growling sound) is a high-current state, and should be avoided.</p>
<p>Continuous-rotation servos will respond to the writeMicrosecond function in an analogous manner to the write function.</p>
<h3 id="read-">read()</h3>
<p>Read the current angle of the servo (the value passed to the last call to write()). Returns an integer from 0 to 180 degrees.</p>
<pre><code class="language-cpp"><span class="comment">// SYNTAX</span>
servo.read()</code></pre>
<h3 id="attached-">attached()</h3>
<p>Check whether the Servo variable is attached to a pin. Returns a boolean.</p>
<pre><code class="language-cpp"><span class="comment">// SYNTAX</span>
servo.attached()</code></pre>
<h3 id="detach-">detach()</h3>
<p>Detach the Servo variable from its pin.</p>
<pre><code class="language-cpp"><span class="comment">// SYNTAX</span>
servo.detach()</code></pre>
<h2 id="rgb">RGB</h2>
<p>This library allows the user to control the RGB LED on the front of the Spark Core.</p>
<pre><code class="language-cpp"><span class="comment">// EXAMPLE CODE</span>

<span class="comment">// take control of the LED</span>
RGB.control(<span class="keyword">true</span>);

<span class="comment">// red, green, blue, 0-255</span>
RGB.color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);

<span class="comment">// wait one second</span>
delay(<span class="number">1000</span>);

<span class="comment">// resume normal operation</span>
RGB.control(<span class="keyword">false</span>);</code></pre>
<h3 id="control-user_control-">control(user_control)</h3>
<p>User can take control of the RGB LED, or give control back to the Spark Core firmware.</p>
<pre><code class="language-cpp"><span class="comment">// take control of the LED</span>
RGB.control(<span class="keyword">true</span>);

<span class="comment">// resume normal operation</span>
RGB.control(<span class="keyword">false</span>);</code></pre>
<h3 id="color-red-green-blue-">color(red, green, blue)</h3>
<p>Set the color of the RGB with three values, 0 to 255 (0 is off, 255 is maximum brightness).</p>
<pre><code class="language-cpp"><span class="comment">// Set the LED to red</span>
RGB.color(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);

<span class="comment">// Sets the LED to cyan</span>
RGB.color(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>);

<span class="comment">// Sets the LED to white</span>
RGB.color(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</code></pre>
<h1 id="other-functions">Other functions</h1>
<h2 id="time">Time</h2>
<h3 id="millis-">millis()</h3>
<p>Returns the number of milliseconds since the Spark Core began running the current program. This number will overflow (go back to zero), after approximately 49 days.</p>
<p><code>unsigned long time = millis();</code></p>
<pre><code class="language-C++">EXAMPLE USAGE
unsigned long time;

void setup()
{
  Serial.begin(9600);
}
void loop()
{
  Serial.print(&quot;Time: &quot;);
  time = millis();
  //prints time since program started
  Serial.println(time);
  // wait a second so as not to send massive amounts of data
  delay(1000);
}</code></pre>
<p><strong>Note:</strong>
The parameter for millis is an unsigned long, errors may be generated if a programmer tries to do math with other datatypes such as ints.</p>
<h3 id="micros-">micros()</h3>
<p><strong>Not implemented yet</strong></p>
<p>Returns the number of microseconds since the Arduino board began running the current program. This number will overflow (go back to zero), after approximately 70 minutes.</p>
<p><code>unsigned long time = micros();</code></p>
<pre><code class="language-C++">EXAMPLE USAGE
unsigned long time;

void setup()
{
  Serial.begin(9600);
}
void loop()
{
  Serial.print(&quot;Time: &quot;);
  time = micros();
  //prints time since program started
  Serial.println(time);
  // wait a second so as not to send massive amounts of data
  delay(1000);
}</code></pre>
<h3 id="delay-">delay()</h3>
<p>Pauses the program for the amount of time (in miliseconds) specified as parameter. (There are 1000 milliseconds in a second.)</p>
<pre><code class="language-C++">SYNTAX
delay(ms);</code></pre>
<p><code>ms</code> is the number of milliseconds to pause <em>(unsigned long)</em></p>
<pre><code class="language-C++">EXAMPLE USAGE
int ledPin = D1;                 // LED connected to digital pin D1

void setup()
{
  pinMode(ledPin, OUTPUT);      // sets the digital pin as output
}

void loop()
{
  digitalWrite(ledPin, HIGH);   // sets the LED on
  delay(1000);                  // waits for a second
  digitalWrite(ledPin, LOW);    // sets the LED off
  delay(1000);                  // waits for a second
}</code></pre>
<p><strong>NOTE:</strong>
the parameter for millis is an unsigned long, errors may be generated if a programmer tries to do math with other datatypes such as ints.</p>
<h3 id="delaymicroseconds-">delayMicroseconds()</h3>
<p><strong>Not implemented yet</strong></p>
<p>Pauses the program for the amount of time (in microseconds) specified as parameter. There are a thousand microseconds in a millisecond, and a million microseconds in a second.</p>
<pre><code class="language-C++">SYNTAX
delayMicroseconds(us);</code></pre>
<p><code>us</code> is the number of microseconds to pause <em>(unsigned int)</em></p>
<pre><code class="language-C++">EXAMPLE USAGE
int outPin = D1;                 // digital pin D1

void setup()
{
  pinMode(outPin, OUTPUT);      // sets the digital pin as output
}

void loop()
{
  digitalWrite(outPin, HIGH);   // sets the pin on
  delayMicroseconds(50);        // pauses for 50 microseconds
  digitalWrite(outPin, LOW);    // sets the pin off
  delayMicroseconds(50);        // pauses for 50 microseconds
}</code></pre>
<h2 id="interrupts">Interrupts</h2>
<h3 id="attachinterrupt-">attachInterrupt()</h3>
<p>Specifies a function to call when an external interrupt occurs. Replaces any previous function that was attached to the interrupt.</p>
<p>The Spark Core currently supports external interrupts on the following pins:</p>
<p>D0, D1, D2, D3, D4<br>A0, A1, A3, A4, A5, A6, A7  </p>
<p><code>attachInterrupt(pin, function, mode);</code></p>
<p><em>Parameters:</em>  </p>
<ul>
<li><code>pin</code>: the pin number</li>
<li><code>function</code>: the function to call when the interrupt occurs; this function must take no parameters and return nothing. This function is sometimes referred to as an <em>interrupt service routine</em> (ISR).</li>
<li><code>mode</code>: defines when the interrupt should be triggered. Four constants are predefined as valid values:<ul>
<li>CHANGE to trigger the interrupt whenever the pin changes value,</li>
<li>RISING to trigger when the pin goes from low to high,</li>
<li>FALLING for when the pin goes from high to low.</li>
</ul>
</li>
</ul>
<p>The function does not return anything.</p>
<p><strong>NOTE:</strong><br>Inside the attached function, <code>delay()</code> won&#39;t work and the value returned by <code>millis()</code> will not increment. Serial data received while in the function may be lost. You should declare as <code>volatile</code> any variables that you modify within the attached function.</p>
<p><em>Using Interrupts:</em><br>Interrupts are useful for making things happen automatically in microcontroller programs, and can help solve timing problems. Good tasks for using an interrupt may include reading a rotary encoder, or monitoring user input.</p>
<p>If you wanted to insure that a program always caught the pulses from a rotary encoder, so that it never misses a pulse, it would make it very tricky to write a program to do anything else, because the program would need to constantly poll the sensor lines for the encoder, in order to catch pulses when they occurred. Other sensors have a similar interface dynamic too, such as trying to read a sound sensor that is trying to catch a click, or an infrared slot sensor (photo-interrupter) trying to catch a coin drop. In all of these situations, using an interrupt can free the microcontroller to get some other work done while not missing the input.</p>
<pre><code class="language-C++">EXAMPLE USAGE
void blink(void);
int ledPin = D1;
volatile int state = LOW;

void setup()
{
  pinMode(ledPin, OUTPUT);
  attachInterrupt(D0, blink, CHANGE);
}

void loop()
{
  digitalWrite(ledPin, state);
}

void blink()
{
  state = !state;
}</code></pre>
<h3 id="detatchinterrupt-">detatchInterrupt()</h3>
<p>Turns off the given interrupt.</p>
<p><code>detachInterrupt(pin);</code></p>
<p><code>pin</code> is the pin number of the interrupt to disable.</p>
<h3 id="interrupts-">interrupts()</h3>
<p>Re-enables interrupts (after they&#39;ve been disabled by <code>noInterrupts()</code>). Interrupts allow certain important tasks to happen in the background and are enabled by default. Some functions will not work while interrupts are disabled, and incoming communication may be ignored. Interrupts can slightly disrupt the timing of code, however, and may be disabled for particularly critical sections of code.</p>
<p><code>interrupts()</code> neither accepts a parameter nor returns anything.</p>
<pre><code class="language-C++">EXAMPLE USAGE
void setup() {}

void loop()
{
  noInterrupts();
  // critical, time-sensitive code here
  interrupts();
  // other code here
}</code></pre>
<h3 id="nointerrupts-">noInterrupts()</h3>
<p>Disables interrupts (you can re-enable them with <code>interrupts()</code>). Interrupts allow certain important tasks to happen in the background and are enabled by default. Some functions will not work while interrupts are disabled, and incoming communication may be ignored. Interrupts can slightly disrupt the timing of code, however, and may be disabled for particularly critical sections of code.</p>
<p><code>noInterrupts()</code> neither accepts a parameter nor returns anything.</p>
<pre><code class="language-C++">EXAMPLE USAGE
void setup() {}

void loop()
{
  noInterrupts();
  // critical, time-sensitive code here
  interrupts();
  // other code here
}</code></pre>
<h2 id="math">Math</h2>
<h3 id="min-">min()</h3>
<p>Calculates the minimum of two numbers.</p>
<p><code>min(x, y)</code></p>
<p><code>x</code> is the first number, any data type<br><code>y</code> is the second number, any data type  </p>
<p>The functions returns the smaller of the two numbers.</p>
<pre><code class="language-C++">EXAMPLE USAGE
sensVal = min(sensVal, 100); // assigns sensVal to the smaller of sensVal or 100
                             // ensuring that it never gets above 100.</code></pre>
<p><strong>NOTE:</strong>
Perhaps counter-intuitively, max() is often used to constrain the lower end of a variable&#39;s range, while min() is used to constrain the upper end of the range.</p>
<p><strong>WARNING:</strong>
Because of the way the min() function is implemented, avoid using other functions inside the brackets, it may lead to incorrect results</p>
<pre><code class="language-C++">min(a++, 100);   // avoid this - yields incorrect results

a++;
min(a, 100);    // use this instead - keep other math outside the function</code></pre>
<h3 id="max-">max()</h3>
<p>Calculates the maximum of two numbers.</p>
<p><code>man(x, y)</code></p>
<p><code>x</code> is the first number, any data type<br><code>y</code> is the second number, any data type  </p>
<p>The functions returns the larger of the two numbers.</p>
<pre><code class="language-C++">EXAMPLE USAGE
sensVal = max(senVal, 20); // assigns sensVal to the larger of sensVal or 20
                           // (effectively ensuring that it is at least 20)</code></pre>
<p><strong>NOTE:</strong>
Perhaps counter-intuitively, max() is often used to constrain the lower end of a variable&#39;s range, while min() is used to constrain the upper end of the range.</p>
<p><strong>WARNING:</strong>
Because of the way the max() function is implemented, avoid using other functions inside the brackets, it may lead to incorrect results</p>
<pre><code class="language-C++">max(a--, 0);   // avoid this - yields incorrect results

a--;           // use this instead -
max(a, 0);     // keep other math outside the function</code></pre>
<h3 id="abs-">abs()</h3>
<p>Computes the absolute value of a number.</p>
<p><code>abs(x);</code></p>
<p>where <code>x</code> is the number  </p>
<p>The function returns <code>x</code> if <code>x</code> is greater than or equal to <code>0</code><br>and returns <code>-x</code> if <code>x</code> is less than <code>0</code>.</p>
<p><strong>WARNING:</strong>
Because of the way the abs() function is implemented, avoid using other functions inside the brackets, it may lead to incorrect results.</p>
<pre><code class="language-C++">abs(a++);   // avoid this - yields incorrect results

a++;          // use this instead -
abs(a);       // keep other math outside the function</code></pre>
<h3 id="constrain-">constrain()</h3>
<p>Constrains a number to be within a range.</p>
<p><code>constrain(x, a, b);</code></p>
<p><code>x</code> is the number to constrain, all data types<br><code>a</code> is the lower end of the range, all data types
<code>b</code> is the upper end of the range, all data types</p>
<p>The function will return:<br><code>x</code>: if x is between <code>a</code> and <code>b</code><br><code>a</code>: if <code>x</code> is less than <code>a</code><br><code>b</code>: if <code>x</code> is greater than <code>b</code></p>
<pre><code class="language-C++">EXAMPLE USAGE
sensVal = constrain(sensVal, 10, 150);
// limits range of sensor values to between 10 and 150</code></pre>
<h3 id="map-">map()</h3>
<p>Re-maps a number from one range to another. That is, a value of fromLow would get mapped to <code>toLow</code>, a <code>value</code> of <code>fromHigh</code> to <code>toHigh</code>, values in-between to values in-between, etc.</p>
<p><code>map(value, fromLow, fromHigh, toLow, toHigh);</code></p>
<p>Does not constrain values to within the range, because out-of-range values are sometimes intended and useful. The <code>constrain()</code> function may be used either before or after this function, if limits to the ranges are desired.</p>
<p>Note that the &quot;lower bounds&quot; of either range may be larger or smaller than the &quot;upper bounds&quot; so the <code>map()</code> function may be used to reverse a range of numbers, for example</p>
<p><code>y = map(x, 1, 50, 50, 1);</code></p>
<p>The function also handles negative numbers well, so that this example</p>
<p><code>y = map(x, 1, 50, 50, -100);</code></p>
<p>is also valid and works well.</p>
<p>The <code>map()</code> function uses integer math so will not generate fractions, when the math might indicate that it should do so. Fractional remainders are truncated, and are not rounded or averaged.</p>
<p><em>Parameters:</em>  </p>
<ul>
<li><code>value</code>: the number to map</li>
<li><code>fromLow</code>: the lower bound of the value&#39;s current range</li>
<li><code>fromHigh</code>: the upper bound of the value&#39;s current range</li>
<li><code>toLow</code>: the lower bound of the value&#39;s target range</li>
<li><code>toHigh</code>: the upper bound of the value&#39;s target range</li>
</ul>
<p>The function returns the mapped value</p>
<pre><code class="language-C++">EXAMPLE USAGE
/* Map an analog value to 8 bits (0 to 255) */
void setup() {}

void loop()
{
  int val = analogRead(0);
  val = map(val, 0, 4095, 0, 255);
  analogWrite(9, val);
}</code></pre>
<p><em>Appendix:</em><br>For the mathematically inclined, here&#39;s the whole function</p>
<pre><code class="language-C++">long map(long x, long in_min, long in_max, long out_min, long out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}</code></pre>
<h3 id="pow-">pow()</h3>
<p>Calculates the value of a number raised to a power. <code>pow()</code> can be used to raise a number to a fractional power. This is useful for generating exponential mapping of values or curves.</p>
<p><code>pow(base, exponent);</code></p>
<p><code>base</code> is the number <em>(float)</em><br><code>exponent</code> is the power to which the base is raised <em>(float)</em></p>
<p>The function returns the result of the exponentiation <em>(double)</em></p>
<p>EXAMPLE <strong>TBD</strong></p>
<h3 id="sqrt-">sqrt()</h3>
<p>Calculates the square root of a number.</p>
<p><code>sqrt(x)</code></p>
<p><code>x</code> is the number, any data type</p>
<p>The function returns the number&#39;s square root <em>(double)</em></p>
<h1 id="language-syntax">Language Syntax</h1>
<p>The following documentation is based on the Arduino reference which can be found <a href="http://arduino.cc/en/Reference/HomePage">here.</a></p>
<h2 id="structure">Structure</h2>
<h3 id="setup-">setup()</h3>
<p>The setup() function is called when an application starts. Use it to initialize variables, pin modes, start using libraries, etc. The setup function will only run once, after each powerup or reset of the Spark Core.</p>
<pre><code class="language-C++">EXAMPLE USAGE
int button = D0;
int LED = D1;
//setup initializes D0 as input and D1 as output
void setup()
{
  pinMode(button, INPUT_PULLDOWN);
  pinMode(LED, OUTPUT);
}

void loop()
{
  // ...
}</code></pre>
<h3 id="loop-">loop()</h3>
<p>After creating a setup() function, which initializes and sets the initial values, the loop() function does precisely what its name suggests, and loops consecutively, allowing your program to change and respond. Use it to actively control the Spark Core.</p>
<pre><code class="language-C++">EXAMPLE USAGE
int button = D0;
int LED = D1;
//setup initializes D0 as input and D1 as output
void setup()
{
  pinMode(button, INPUT_PULLDOWN);
  pinMode(LED, OUTPUT);
}

//loops to check if button was pressed,
//if it was, then it turns ON the LED,
//else the LED remains OFF
void loop()
{
  if (digitalRead(button) == HIGH)
    digitalWrite(LED,HIGH);
  else
    digitalWrite(LED,LOW);
}</code></pre>
<h2 id="control-structures">Control structures</h2>
<h3 id="if">if</h3>
<p><code>if</code>, which is used in conjunction with a comparison operator, tests whether a certain condition has been reached, such as an input being above a certain number.</p>
<pre><code class="language-C++">SYNTAX
if (someVariable &gt; 50)
{
  // do something here
}</code></pre>
<p>The program tests to see if someVariable is greater than 50. If it is, the program takes a particular action. Put another way, if the statement in parentheses is true, the statements inside the brackets are run. If not, the program skips over the code.</p>
<p>The brackets may be omitted after an <em>if</em> statement. If this is done, the next line (defined by the semicolon) becomes the only conditional statement.</p>
<pre><code class="language-C++">if (x &gt; 120) digitalWrite(LEDpin, HIGH);

if (x &gt; 120)
digitalWrite(LEDpin, HIGH);

if (x &gt; 120){ digitalWrite(LEDpin, HIGH); }

if (x &gt; 120)
{
  digitalWrite(LEDpin1, HIGH);
  digitalWrite(LEDpin2, HIGH);
}                                 // all are correct</code></pre>
<p>The statements being evaluated inside the parentheses require the use of one or more operators:</p>
<h3 id="comparison-operators">Comparison Operators</h3>
<pre><code class="language-C++">x == y (x is equal to y)
x != y (x is not equal to y)
x &lt;  y (x is less than y)  
x &gt;  y (x is greater than y)
x &lt;= y (x is less than or equal to y)
x &gt;= y (x is greater than or equal to y)</code></pre>
<p><strong>WARNING:</strong>
Beware of accidentally using the single equal sign (e.g. <code>if (x = 10)</code> ). The single equal sign is the assignment operator, and sets x to 10 (puts the value 10 into the variable x). Instead use the double equal sign (e.g. <code>if (x == 10)</code> ), which is the comparison operator, and tests whether x is equal to 10 or not. The latter statement is only true if x equals 10, but the former statement will always be true.</p>
<p>This is because C evaluates the statement <code>if (x=10)</code> as follows: 10 is assigned to x (remember that the single equal sign is the assignment operator), so x now contains 10. Then the &#39;if&#39; conditional evaluates 10, which always evaluates to TRUE, since any non-zero number evaluates to TRUE. Consequently, <code>if (x = 10)</code> will always evaluate to TRUE, which is not the desired result when using an &#39;if&#39; statement. Additionally, the variable x will be set to 10, which is also not a desired action.</p>
<p><code>if</code> can also be part of a branching control structure using the <code>if...else</code>] construction.</p>
<h3 id="if-else">if...else</h3>
<p><em>if/else</em> allows greater control over the flow of code than the basic <em>if</em> statement, by allowing multiple tests to be grouped together. For example, an analog input could be tested and one action taken if the input was less than 500, and another action taken if the input was 500 or greater. The code would look like this:</p>
<pre><code class="language-C++">SYNTAX
if (pinFiveInput &lt; 500)
{
  // action A
}
else
{
  // action B
}</code></pre>
<p><code>else</code> can proceed another <code>if</code> test, so that multiple, mutually exclusive tests can be run at the same time.</p>
<p>Each test will proceed to the next one until a true test is encountered. When a true test is found, its associated block of code is run, and the program then skips to the line following the entire if/else construction. If no test proves to be true, the default else block is executed, if one is present, and sets the default behavior.</p>
<p>Note that an <em>else if</em> block may be used with or without a terminating <em>else</em> block and vice versa. An unlimited number of such else if branches is allowed.</p>
<pre><code class="language-C++">if (pinFiveInput &lt; 500)
{
  // do Thing A
}
else if (pinFiveInput &gt;= 1000)
{
  // do Thing B
}
else
{
  // do Thing C
}</code></pre>
<p>Another way to express branching, mutually exclusive tests, is with the <a href="http://spark.github.io/docs/#control-structures-switch-case"><code>switch case</code></a> statement.</p>
<h3 id="for">for</h3>
<p>The <code>for</code> statement is used to repeat a block of statements enclosed in curly braces. An increment counter is usually used to increment and terminate the loop. The <code>for</code> statement is useful for any repetitive operation, and is often used in combination with arrays to operate on collections of data/pins.</p>
<p>There are three parts to the for loop header:</p>
<pre><code class="language-C++">SYNTAX
for (initialization; condition; increment)
{
  //statement(s);
}</code></pre>
<p>The <em>initialization</em> happens first and exactly once. Each time through the loop, the <em>condition</em> is tested; if it&#39;s true, the statement block, and the <em>increment</em> is executed, then the condition is tested again. When the <em>condition</em> becomes false, the loop ends.</p>
<pre><code class="language-C++">EXAMPLE USAGE
// slowy make the LED glow brighter
int ledPin = D1; // LED in series with 470 ohm resistor on pin D1

void setup()
{
  // set ledPin as an output
  pinMode(ledPin,OUTPUT);
}

void loop()
{
   for (int i=0; i &lt;= 255; i++){
      analogWrite(ledPin, i);
      delay(10);
   }
}</code></pre>
<p>The C <code>for</code> loop is much more flexible than for loops found in some other computer languages, including BASIC. Any or all of the three header elements may be omitted, although the semicolons are required. Also the statements for initialization, condition, and increment can be any valid C statements with unrelated variables, and use any C datatypes including floats. These types of unusual for statements may provide solutions to some rare programming problems.</p>
<p>For example, using a multiplication in the increment line will generate a logarithmic progression:</p>
<pre><code class="language-C++">for(int x = 2; x &lt; 100; x = x * 1.5)
{
  Serial.print(x);
}
//Generates: 2,3,4,6,9,13,19,28,42,63,94</code></pre>
<p>Another example, fade an LED up and down with one for loop:</p>
<pre><code class="language-C++">// slowy make the LED glow brighter
int ledPin = D1; // LED in series with 470 ohm resistor on pin D1

void setup()
{
  // set ledPin as an output
  pinMode(ledPin,OUTPUT);
}

void loop()
{
   int x = 1;
   for (int i = 0; i &gt; -1; i = i + x)
   {
      analogWrite(ledPin, i);
      if (i == 255) x = -1;     // switch direction at peak
      delay(10);
   }
}</code></pre>
<h3 id="switch-case">switch case</h3>
<p>Like <code>if</code> statements, <code>switch</code>...<code>case</code> controls the flow of programs by allowing programmers to specify different code that should be executed in various conditions. In particular, a switch statement compares the value of a variable to the values specified in case statements. When a case statement is found whose value matches that of the variable, the code in that case statement is run.</p>
<p>The <code>break</code> keyword exits the switch statement, and is typically used at the end of each case. Without a break statement, the switch statement will continue executing the following expressions (&quot;falling-through&quot;) until a break, or the end of the switch statement is reached.</p>
<pre><code class="language-C++">SYNTAX
switch (var)
{
  case label:
    // statements
    break;
  case label:
    // statements
    break;
  default:
    // statements
}</code></pre>
<p><code>var</code> is the variable whose value to compare to the various cases
<code>label</code> is a value to compare the variable to</p>
<pre><code class="language-C++">EXAMPLE USAGE
switch (var)
{
    case 1:
      //do something when var equals 1
      break;
    case 2:
      //do something when var equals 2
      break;
    default:
      // if nothing else matches, do the default
      // default is optional
}</code></pre>
<h3 id="while">while</h3>
<p><code>while</code> loops will loop continuously, and infinitely, until the expression inside the parenthesis, () becomes false. Something must change the tested variable, or the <code>while</code> loop will never exit. This could be in your code, such as an incremented variable, or an external condition, such as testing a sensor.</p>
<pre><code class="language-C++">SYNTAX
while(expression)
{
  // statement(s)
}</code></pre>
<p><code>expression</code> is a (boolean) C statement that evaluates to true or false.</p>
<pre><code class="language-C++">EXAMPLE USAGE
var = 0;
while(var &lt; 200)
{
  // do something repetitive 200 times
  var++;
}</code></pre>
<h3 id="do-while">do... while</h3>
<p>The <code>do</code> loop works in the same manner as the <code>while</code> loop, with the exception that the condition is tested at the end of the loop, so the do loop will <em>always</em> run at least once.</p>
<pre><code class="language-C++">SYNTAX
do
{
    // statement block
} while (test condition);</code></pre>
<pre><code class="language-C++">EXAMPLE USAGE
do
{
  delay(50);          // wait for sensors to stabilize
  x = readSensors();  // check the sensors

} while (x &lt; 100);</code></pre>
<h3 id="break">break</h3>
<p><code>break</code> is used to exit from a <code>do</code>, <code>for</code>, or <code>while</code> loop, bypassing the normal loop condition. It is also used to exit from a <code>switch</code> statement.</p>
<pre><code class="language-C++">EXAMPLE USAGE
for (int x = 0; x &lt; 255; x ++)
{
    digitalWrite(ledPin, x);
    sens = analogRead(sensorPin);  
    if (sens &gt; threshold)         // bail out on sensor detect
    {
       x = 0;
       break;
    }  
    delay(50);
}</code></pre>
<h3 id="continue">continue</h3>
<p>The continue statement skips the rest of the current iteration of a loop (<code>do</code>, <code>for</code>, or <code>while</code>). It continues by checking the conditional expression of the loop, and proceeding with any subsequent iterations.</p>
<pre><code class="language-C++">EXAMPLE USAGE
for (x = 0; x &lt; 255; x ++)
{
    if (x &gt; 40 &amp;&amp; x &lt; 120) continue;    // create jump in values

    digitalWrite(PWMpin, x);
    delay(50);
}</code></pre>
<h3 id="return">return</h3>
<p>Terminate a function and return a value from a function to the calling function, if desired.</p>
<pre><code class="language-C++">EXAMPLE
// A function to compare a sensor input to a threshold
 int checkSensor()
 {
    if (analogRead(0) &gt; 400) return 1;
    else return 0;
}</code></pre>
<p>The return keyword is handy to test a section of code without having to &quot;comment out&quot; large sections of possibly buggy code.</p>
<pre><code class="language-C++">void loop()
{
  // brilliant code idea to test here

  return;

  // the rest of a dysfunctional sketch here
  // this code will never be executed
}</code></pre>
<h3 id="goto">goto</h3>
<p>Transfers program flow to a labeled point in the program</p>
<pre><code class="language-C++">USAGE
label:

goto label; // sends program flow to the label</code></pre>
<p><strong>TIP:</strong>
The use of <code>goto</code> is discouraged in C programming, and some authors of C programming books claim that the <code>goto</code> statement is never necessary, but used judiciously, it can simplify certain programs. The reason that many programmers frown upon the use of <code>goto</code> is that with the unrestrained use of <code>goto</code> statements, it is easy to create a program with undefined program flow, which can never be debugged.</p>
<p>With that said, there are instances where a <code>goto</code> statement can come in handy, and simplify coding. One of these situations is to break out of deeply nested <code>for</code> loops, or <code>if</code> logic blocks, on a certain condition.</p>
<pre><code class="language-C++">EXAMPLE USAGE
for(byte r = 0; r &lt; 255; r++){
    for(byte g = 255; g &gt; -1; g--){
        for(byte b = 0; b &lt; 255; b++){
            if (analogRead(0) &gt; 250){ goto bailout;}
            // more statements ...
        }
    }
}
bailout:</code></pre>
<h2 id="further-syntax">Further syntax</h2>
<h3 id="-semicolon-">; (semicolon)</h3>
<p>Used to end a statement.</p>
<p><code>int a = 13;</code></p>
<p><strong>Tip:</strong>
Forgetting to end a line in a semicolon will result in a compiler error. The error text may be obvious, and refer to a missing semicolon, or it may not. If an impenetrable or seemingly illogical compiler error comes up, one of the first things to check is a missing semicolon, in the immediate vicinity, preceding the line at which the compiler complained.</p>
<h3 id="-curly-braces-">{} (curly braces)</h3>
<p>Curly braces (also referred to as just &quot;braces&quot; or as &quot;curly brackets&quot;) are a major part of the C programming language. They are used in several different constructs, outlined below, and this can sometimes be confusing for beginners.</p>
<pre><code class="language-C++">//The main uses of curly braces

//Functions
  void myfunction(datatype argument){
    statements(s)
  }

//Loops
  while (boolean expression)
  {
     statement(s)
  }

  do
  {
     statement(s)
  } while (boolean expression);

  for (initialisation; termination condition; incrementing expr)
  {
     statement(s)
  }

//Conditional statements
  if (boolean expression)
  {
     statement(s)
  }

  else if (boolean expression)
  {
     statement(s)
  }
  else
  {
     statement(s)
  }</code></pre>
<p>An opening curly brace &quot;{&quot; must always be followed by a closing curly brace &quot;}&quot;. This is a condition that is often referred to as the braces being balanced.</p>
<p>Beginning programmers, and programmers coming to C from the BASIC language often find using braces confusing or daunting. After all, the same curly braces replace the RETURN statement in a subroutine (function), the ENDIF statement in a conditional and the NEXT statement in a FOR loop.</p>
<p>Because the use of the curly brace is so varied, it is good programming practice to type the closing brace immediately after typing the opening brace when inserting a construct which requires curly braces. Then insert some carriage returns between your braces and begin inserting statements. Your braces, and your attitude, will never become unbalanced.</p>
<p>Unbalanced braces can often lead to cryptic, impenetrable compiler errors that can sometimes be hard to track down in a large program. Because of their varied usages, braces are also incredibly important to the syntax of a program and moving a brace one or two lines will often dramatically affect the meaning of a program.</p>
<h3 id="-single-line-comment-">// (single line comment)</h3>
<h3 id="-multi-line-comment-">/* */ (multi-line comment)</h3>
<p>Comments are lines in the program that are used to inform yourself or others about the way the program works. They are ignored by the compiler, and not exported to the processor, so they don&#39;t take up any space on the Spark Core.</p>
<p>Comments only purpose are to help you understand (or remember) how your program works or to inform others how your program works. There are two different ways of marking a line as a comment:</p>
<pre><code class="language-C++">EXAMPLE USAGE
 x = 5;  // This is a single line comment. Anything after the slashes is a comment
         // to the end of the line

/* this is multiline comment - use it to comment out whole blocks of code

if (gwb == 0){   // single line comment is OK inside a multiline comment
x = 3;           /* but not another multiline comment - this is invalid */
}
// don&#39;t forget the &quot;closing&quot; comment - they have to be balanced!
*/</code></pre>
<p><strong>TIP:</strong>
When experimenting with code, &quot;commenting out&quot; parts of your program is a convenient way to remove lines that may be buggy. This leaves the lines in the code, but turns them into comments, so the compiler just ignores them. This can be especially useful when trying to locate a problem, or when a program refuses to compile and the compiler error is cryptic or unhelpful.</p>
<h3 id="-define">#define</h3>
<p><code>#define</code> is a useful C component that allows the programmer to give a name to a constant value before the program is compiled. Defined constants don&#39;t take up any program memory space on the chip. The compiler will replace references to these constants with the defined value at compile time.</p>
<p><code>#define constantName value</code><br>Note that the # is necessary.</p>
<p>This can have some unwanted side effects though, if for example, a constant name that had been <code>#defined</code> is included in some other constant or variable name. In that case the text would be replaced by the #defined number (or text).</p>
<pre><code class="language-C++">EXAMPLE USAGE
#define ledPin 3
// The compiler will replace any mention of ledPin with the value 3 at compile time.</code></pre>
<p>In general, the <a href="">const</a> keyword is preferred for defining constants and should be used instead of #define.</p>
<p><strong>TIP:</strong>
There is no semicolon after the #define statement. If you include one, the compiler will throw cryptic errors further down the page.</p>
<p><code>#define ledPin 3;    // this is an error</code></p>
<p>Similarly, including an equal sign after the #define statement will also generate a cryptic compiler error further down the page.</p>
<p><code>#define ledPin  = 3  // this is also an error</code></p>
<h3 id="-include">#include</h3>
<p><code>#include</code> is used to include outside libraries in your application code. This gives the programmer access to a large group of standard C libraries (groups of pre-made functions), and also libraries written especially for Spark Core.</p>
<p>Note that #include, similar to #define, has no semicolon terminator, and the compiler will yield cryptic error messages if you add one.</p>
<h2 id="arithmetic-operators">Arithmetic operators</h2>
<h3 id="-assignment-operator-">= (assignment operator)</h3>
<p>Stores the value to the right of the equal sign in the variable to the left of the equal sign.</p>
<p>The single equal sign in the C programming language is called the assignment operator. It has a different meaning than in algebra class where it indicated an equation or equality. The assignment operator tells the microcontroller to evaluate whatever value or expression is on the right side of the equal sign, and store it in the variable to the left of the equal sign.</p>
<pre><code class="language-C++">EXAMPLE USAGE
int sensVal;                // declare an integer variable named sensVal
senVal = analogRead(A0);    // store the (digitized) input voltage at analog pin A0 in SensVal</code></pre>
<p><strong>TIP:</strong>
The variable on the left side of the assignment operator ( = sign ) needs to be able to hold the value stored in it. If it is not large enough to hold a value, the value stored in the variable will be incorrect.</p>
<p>Don&#39;t confuse the assignment operator <code>=</code> (single equal sign) with the comparison operator <code>==</code> (double equal signs), which evaluates whether two expressions are equal.</p>
<h3 id="-additon-subtraction-multiplication-division-">+ - * / (additon subtraction multiplication division)</h3>
<p>These operators return the sum, difference, product, or quotient (respectively) of the two operands. The operation is conducted using the data type of the operands, so, for example,<code>9 / 4</code> gives 2 since 9 and 4 are ints. This also means that the operation can overflow if the result is larger than that which can be stored in the data type (e.g. adding 1 to an int with the value 2,147,483,647 gives -2,147,483,648). If the operands are of different types, the &quot;larger&quot; type is used for the calculation.</p>
<p>If one of the numbers (operands) are of the type float or of type double, floating point math will be used for the calculation.</p>
<pre><code class="language-C++">EXAMPLE USAGES
y = y + 3;
x = x - 7;
i = j * 6;
r = r / 5;</code></pre>
<pre><code class="language-C++">SYNTAX
result = value1 + value2;
result = value1 - value2;
result = value1 * value2;
result = value1 / value2;</code></pre>
<p><code>value1</code> and <code>value2</code> can be any variable or constant.</p>
<p><strong>TIPS:</strong></p>
<ul>
<li>Know that integer constants default to int, so some constant calculations may overflow (e.g. 50 * 50,000,000 will yield a negative result).</li>
<li>Choose variable sizes that are large enough to hold the largest results from your calculations  </li>
<li>Know at what point your variable will &quot;roll over&quot; and also what happens in the other direction e.g. (0 - 1) OR (0 + 2147483648)  </li>
<li>For math that requires fractions, use float variables, but be aware of their drawbacks: large size, slow computation speeds  </li>
<li>Use the cast operator e.g. (int)myFloat to convert one variable type to another on the fly.  </li>
</ul>
<h3 id="-modulo-">% (modulo)</h3>
<p>Calculates the remainder when one integer is divided by another. It is useful for keeping a variable within a particular range (e.g. the size of an array).  It is defined so that <code>a % b == a - ((a / b) * b)</code>.  </p>
<p><code>result = dividend % divisor</code></p>
<p><code>dividend</code> is the number to be divided and<br><code>divisor</code> is the number to divide by.</p>
<p><code>result</code> is the remainder</p>
<p>The remainder function can have unexpected behavoir when some of the opperands are negative.  If the dividend is negative, then the result will be the smallest negative equivalency class.  In other words, when <code>a</code> is negative, <code>(a % b) == (a mod b) - b</code> where (a mod b) follows the standard mathematical definition of mod.  When the divisor is negative, the result is the same as it would be if it was positive.  </p>
<pre><code class="language-C++">EXAMPLE USAGES
x = 9 % 5;   // x now contains 4
x = 5 % 5;   // x now contains 0
x = 4 % 5;   // x now contains 4
x = 7 % 5;   // x now contains 2
x = -7 % 5;  // x now contains -2
x = 7 % -5;  // x now contains 2
x = -7 % -5; // x now contains -2</code></pre>
<pre><code class="language-C++">EXAMPLE CODE
//update one value in an array each time through a loop

int values[10];
int i = 0;

void setup() {}

void loop()
{
  values[i] = analogRead(A0);
  i = (i + 1) % 10;   // modulo operator rolls over variable  
}</code></pre>
<p><strong>TIP:</strong>
The modulo operator does not work on floats.  For floats, an equivalent expression to <code>a % b</code> is <code>a - (b * ((int)(a / b)))</code></p>
<h2 id="boolean-operators">Boolean operators</h2>
<p>These can be used inside the condition of an if statement.</p>
<h3 id="-and-">&amp;&amp; (and)</h3>
<p>True only if both operands are true, e.g.</p>
<pre><code class="language-C++">if (digitalRead(D2) == HIGH  &amp;&amp; digitalRead(D3) == HIGH)
{
  // read two switches
  // ...
}
//is true only if both inputs are high.</code></pre>
<h3 id="-or-">|| (or)</h3>
<p>True if either operand is true, e.g.</p>
<pre><code class="language-C++">if (x &gt; 0 || y &gt; 0)
{
  // ...
}
//is true if either x or y is greater than 0.</code></pre>
<h3 id="-not-">! (not)</h3>
<p>True if the operand is false, e.g.</p>
<pre><code class="language-C++">if (!x)
{
  // ...
}
//is true if x is false (i.e. if x equals 0).</code></pre>
<p><strong>WARNING:</strong><br>Make sure you don&#39;t mistake the boolean AND operator, &amp;&amp; (double ampersand) for the bitwise AND operator &amp; (single ampersand). They are entirely different beasts.</p>
<p>Similarly, do not confuse the boolean || (double pipe) operator with the bitwise OR operator | (single pipe).</p>
<p>The bitwise not ~ (tilde) looks much different than the boolean not ! (exclamation point or &quot;bang&quot; as the programmers say) but you still have to be sure which one you want where.</p>
<p><code>if (a &gt;= 10 &amp;&amp; a &lt;= 20){}   // true if a is between 10 and 20</code></p>
<h2 id="bitwise-operators">Bitwise operators</h2>
<h3 id="-bitwise-and-">&amp; (bitwise and)</h3>
<p>The bitwise AND operator in C++ is a single ampersand, &amp;, used between two other integer expressions. Bitwise AND operates on each bit position of the surrounding expressions independently, according to this rule: if both input bits are 1, the resulting output is 1, otherwise the output is 0. Another way of expressing this is:</p>
<pre><code>    0  0  1  1    operand1
    0  1  0  1    operand2
    ----------
    0  0  0  1    (operand1 &amp; operand2) - returned result</code></pre>
<pre><code class="language-C++">EXAMPLE USAGE
int a =  92;    // in binary: 0000000001011100
int b = 101;    // in binary: 0000000001100101
int c = a &amp; b;  // result:    0000000001000100, or 68 in decimal.</code></pre>
<p>One of the most common uses of bitwise AND is to select a particular bit (or bits) from an integer value, often called masking.</p>
<h3 id="-bitwise-or-">| (bitwise or)</h3>
<p>The bitwise OR operator in C++ is the vertical bar symbol, |. Like the &amp; operator, | operates independently each bit in its two surrounding integer expressions, but what it does is different (of course). The bitwise OR of two bits is 1 if either or both of the input bits is 1, otherwise it is 0. In other words:</p>
<pre><code>    0  0  1  1    operand1
    0  1  0  1    operand2
    ----------
    0  1  1  1    (operand1 | operand2) - returned result</code></pre>
<pre><code class="language-C++">EXAMPLE USAGE
int a =  92;    // in binary: 0000000001011100
int b = 101;    // in binary: 0000000001100101
int c = a | b;  // result:    0000000001111101, or 125 in decimal.</code></pre>
<h3 id="-bitwise-xor-">^ (bitwise xor)</h3>
<p>There is a somewhat unusual operator in C++ called bitwise EXCLUSIVE OR, also known as bitwise XOR. (In English this is usually pronounced &quot;eks-or&quot;.) The bitwise XOR operator is written using the caret symbol ^. This operator is very similar to the bitwise OR operator |, only it evaluates to 0 for a given bit position when both of the input bits for that position are 1:</p>
<pre><code>    0  0  1  1    operand1
    0  1  0  1    operand2
    ----------
    0  1  1  0    (operand1 ^ operand2) - returned result</code></pre>
<p>Another way to look at bitwise XOR is that each bit in the result is a 1 if the input bits are different, or 0 if they are the same.</p>
<pre><code class="language-C++">EXAMPLE USAGE
int x = 12;     // binary: 1100
int y = 10;     // binary: 1010
int z = x ^ y;  // binary: 0110, or decimal 6</code></pre>
<p>The ^ operator is often used to toggle (i.e. change from 0 to 1, or 1 to 0) some of the bits in an integer expression. In a bitwise OR operation if there is a 1 in the mask bit, that bit is inverted; if there is a 0, the bit is not inverted and stays the same.</p>
<h3 id="-bitwise-not-">~ (bitwise not)</h3>
<p>The bitwise NOT operator in C++ is the tilde character ~. Unlike &amp; and |, the bitwise NOT operator is applied to a single operand to its right. Bitwise NOT changes each bit to its opposite: 0 becomes 1, and 1 becomes 0. For example:</p>
<pre><code>    0  1    operand1
   ----------
    1  0   ~ operand1

int a = 103;    // binary:  0000000001100111
int b = ~a;     // binary:  1111111110011000 = -104</code></pre>
<p>You might be surprised to see a negative number like -104 as the result of this operation. This is because the highest bit in an int variable is the so-called sign bit. If the highest bit is 1, the number is interpreted as negative. This encoding of positive and negative numbers is referred to as two&#39;s complement. For more information, see the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Twos_complement">two&#39;s complement.</a></p>
<p>As an aside, it is interesting to note that for any integer x, ~x is the same as -x-1.</p>
<p>At times, the sign bit in a signed integer expression can cause some unwanted surprises.</p>
<h3 id="-bitwise-left-shift-bitwise-right-shift-">&lt;&lt; (bitwise left shift), &gt;&gt; (bitwise right shift)</h3>
<p>There are two bit shift operators in C++: the left shift operator &lt;&lt; and the right shift operator &gt;&gt;. These operators cause the bits in the left operand to be shifted left or right by the number of positions specified by the right operand.</p>
<p>More on bitwise math may be found <a href="http://www.arduino.cc/playground/Code/BitMath">here.</a></p>
<pre><code>variable &lt;&lt; number_of_bits
variable &gt;&gt; number_of_bits</code></pre>
<p><code>variable</code> can be <code>byte</code>, <code>int</code>, <code>long</code><br><code>number_of_bits</code> and integer &lt;= 32  </p>
<pre><code class="language-C++">EXAMPLE USAGE
int a = 5;        // binary: 0000000000000101
int b = a &lt;&lt; 3;   // binary: 0000000000101000, or 40 in decimal
int c = b &gt;&gt; 3;   // binary: 0000000000000101, or back to 5 like we started with</code></pre>
<p>When you shift a value x by y bits (x &lt;&lt; y), the leftmost y bits in x are lost, literally shifted out of existence:</p>
<pre><code class="language-C++">int a = 5;        // binary: 0000000000000101
int b = a &lt;&lt; 14;  // binary: 0100000000000000 - the first 1 in 101 was discarded</code></pre>
<p>If you are certain that none of the ones in a value are being shifted into oblivion, a simple way to think of the left-shift operator is that it multiplies the left operand by 2 raised to the right operand power. For example, to generate powers of 2, the following expressions can be employed:</p>
<pre><code>1 &lt;&lt;  0  ==    1
1 &lt;&lt;  1  ==    2
1 &lt;&lt;  2  ==    4
1 &lt;&lt;  3  ==    8
...
1 &lt;&lt;  8  ==  256
1 &lt;&lt;  9  ==  512
1 &lt;&lt; 10  == 1024
...</code></pre>
<p>When you shift x right by y bits (x &gt;&gt; y), and the highest bit in x is a 1, the behavior depends on the exact data type of x. If x is of type int, the highest bit is the sign bit, determining whether x is negative or not, as we have discussed above. In that case, the sign bit is copied into lower bits, for esoteric historical reasons:</p>
<pre><code class="language-C++">int x = -16;     // binary: 1111111111110000
int y = x &gt;&gt; 3;  // binary: 1111111111111110</code></pre>
<p>This behavior, called sign extension, is often not the behavior you want. Instead, you may wish zeros to be shifted in from the left. It turns out that the right shift rules are different for unsigned int expressions, so you can use a typecast to suppress ones being copied from the left:</p>
<pre><code class="language-C++">int x = -16;                   // binary: 1111111111110000
int y = (unsigned int)x &gt;&gt; 3;  // binary: 0001111111111110</code></pre>
<p>If you are careful to avoid sign extension, you can use the right-shift operator &gt;&gt; as a way to divide by powers of 2. For example:</p>
<pre><code class="language-C++">int x = 1000;
int y = x &gt;&gt; 3;   // integer division of 1000 by 8, causing y = 125</code></pre>
<h2 id="compound-operators">Compound operators</h2>
<h3 id="-increment-decrement-">++ (increment), -- (decrement)</h3>
<p>Increment or decrement a variable</p>
<pre><code class="language-C++">SYNTAX
x++;  // increment x by one and returns the old value of x
++x;  // increment x by one and returns the new value of x

x-- ;   // decrement x by one and returns the old value of x
--x ;   // decrement x by one and returns the new value of x</code></pre>
<p>where <code>x</code> is an integer or long (possibly unsigned)</p>
<pre><code class="language-C++">EXAMPLE USAGE
x = 2;
y = ++x;      // x now contains 3, y contains 3
y = x--;      // x contains 2 again, y still contains 3</code></pre>
<h3 id="compound-arithmetic">compound arithmetic</h3>
<ul>
<li>+= (compound addition)</li>
<li>-= (compound subtraction)</li>
<li>*= (compound multiplication)</li>
<li>/= (compound division)</li>
</ul>
<p>Perform a mathematical operation on a variable with another constant or variable. The += (et al) operators are just a convenient shorthand for the expanded syntax.</p>
<pre><code class="language-C++">SYNTAX
x += y;   // equivalent to the expression x = x + y;
x -= y;   // equivalent to the expression x = x - y;
x *= y;   // equivalent to the expression x = x * y;
x /= y;   // equivalent to the expression x = x / y;</code></pre>
<p><code>x</code> can be any variable type<br><code>y</code> can be any variable type or constant</p>
<pre><code class="language-C++">EXAMPLE USAGE
x = 2;
x += 4;      // x now contains 6
x -= 3;      // x now contains 3
x *= 10;     // x now contains 30
x /= 2;      // x now contains 15</code></pre>
<h3 id="-compound-bitwise-and-">&amp;= (compound bitwise and)</h3>
<p>The compound bitwise AND operator (&amp;=) is often used with a variable and a constant to force particular bits in a variable to the LOW state (to 0). This is often referred to in programming guides as &quot;clearing&quot; or &quot;resetting&quot; bits.</p>
<p><code>x &amp;= y;   // equivalent to x = x &amp; y;</code></p>
<p><code>x</code> can be a char, int or long variable<br><code>y</code> can be an integer constant, char, int, or long  </p>
<pre><code>   0  0  1  1    operand1
   0  1  0  1    operand2
   ----------
   0  0  0  1    (operand1 &amp; operand2) - returned result</code></pre>
<p>Bits that are &quot;bitwise ANDed&quot; with 0 are cleared to 0 so, if myByte is a byte variable,<br><code>myByte &amp; B00000000 = 0;</code>  </p>
<p>Bits that are &quot;bitwise ANDed&quot; with 1 are unchanged so,<br><code>myByte &amp; B11111111 = myByte;</code></p>
<p><strong>Note:</strong> because we are dealing with bits in a bitwise operator - it is convenient to use the binary formatter with constants. The numbers are still the same value in other representations, they are just not as easy to understand. Also, B00000000 is shown for clarity, but zero in any number format is zero (hmmm something philosophical there?)</p>
<p>Consequently - to clear (set to zero) bits 0 &amp; 1 of a variable, while leaving the rest of the variable unchanged, use the compound bitwise AND operator (&amp;=) with the constant B11111100</p>
<pre><code>   1  0  1  0  1  0  1  0    variable  
   1  1  1  1  1  1  0  0    mask
   ----------------------
   1  0  1  0  1  0  0  0

 variable unchanged
                     bits cleared</code></pre>
<p>Here is the same representation with the variable&#39;s bits replaced with the symbol x</p>
<pre><code>   x  x  x  x  x  x  x  x    variable
   1  1  1  1  1  1  0  0    mask
   ----------------------
   x  x  x  x  x  x  0  0

 variable unchanged
                     bits cleared</code></pre>
<p>So if:<br><code>myByte =  10101010;</code><br><code>myByte &amp;= B1111100 == B10101000;</code></p>
<h3 id="-compound-bitwise-or-">|= (compound bitwise or)</h3>
<p>The compound bitwise OR operator (|=) is often used with a variable and a constant to &quot;set&quot; (set to 1) particular bits in a variable.</p>
<pre><code class="language-C++">SYNTAX
x |= y;   // equivalent to x = x | y;</code></pre>
<p><code>x</code> can be a char, int or long variable<br><code>y</code> can be an integer constant or char, int or long  </p>
<pre><code>   0  0  1  1    operand1
   0  1  0  1    operand2
   ----------
   0  1  1  1    (operand1 | operand2) - returned result</code></pre>
<p>Bits that are &quot;bitwise ORed&quot; with 0 are unchanged, so if myByte is a byte variable,<br><code>myByte | B00000000 = myByte;</code></p>
<p>Bits that are &quot;bitwise ORed&quot; with 1 are set to 1 so:<br><code>myByte | B11111111 = B11111111;</code></p>
<p>Consequently - to set bits 0 &amp; 1 of a variable, while leaving the rest of the variable unchanged, use the compound bitwise OR operator (|=) with the constant B00000011</p>
<pre><code>   1  0  1  0  1  0  1  0    variable
   0  0  0  0  0  0  1  1    mask
   ----------------------
   1  0  1  0  1  0  1  1

 variable unchanged
                     bits set</code></pre>
<p>Here is the same representation with the variables bits replaced with the symbol x</p>
<pre><code>   x  x  x  x  x  x  x  x    variable
   0  0  0  0  0  0  1  1    mask
   ----------------------
   x  x  x  x  x  x  1  1

 variable unchanged
                     bits set</code></pre>
<p>So if:<br><code>myByte =  B10101010;</code><br><code>myByte |= B00000011 == B10101011;</code>  </p>
<h1 id="variables">Variables</h1>
<h2 id="constants">Constants</h2>
<h3 id="high-low">HIGH | LOW</h3>
<p>When reading or writing to a digital pin there are only two possible values a pin can take/be-set-to: HIGH and LOW.</p>
<p><code>HIGH</code></p>
<p>The meaning of <code>HIGH</code> (in reference to a pin) is somewhat different depending on whether a pin is set to an <code>INPUT</code> or <code>OUTPUT</code>. When a pin is configured as an INPUT with pinMode, and read with digitalRead, the microcontroller will report HIGH if a voltage of 3 volts or more is present at the pin.</p>
<p>A pin may also be configured as an <code>INPUT</code> with <code>pinMode</code>, and subsequently made <code>HIGH</code> with <code>digitalWrite</code>, this will set the internal 40K pullup resistors, which will steer the input pin to a <code>HIGH</code> reading unless it is pulled LOW by external circuitry. This is how INPUT_PULLUP works as well</p>
<p>When a pin is configured to <code>OUTPUT</code> with <code>pinMode</code>, and set to <code>HIGH</code> with <code>digitalWrite</code>, the pin is at 3.3 volts. In this state it can source current, e.g. light an LED that is connected through a series resistor to ground, or to another pin configured as an output, and set to <code>LOW.</code></p>
<p><code>LOW</code></p>
<p>The meaning of <code>LOW</code> also has a different meaning depending on whether a pin is set to <code>INPUT</code> or <code>OUTPUT</code>. When a pin is configured as an <code>INPUT</code> with <code>pinMode</code>, and read with <code>digitalRead</code>, the microcontroller will report <code>LOW</code> if a voltage of 1.5 volts or less is present at the pin.</p>
<p>When a pin is configured to <code>OUTPUT</code> with <code>pinMode</code>, and set to <code>LOW</code> with digitalWrite, the pin is at 0 volts. In this state it can sink current, e.g. light an LED that is connected through a series resistor to, +3.3 volts, or to another pin configured as an output, and set to <code>HIGH.</code></p>
<h3 id="input-output-input_pullup-input_pulldown">INPUT, OUTPUT, INPUT_PULLUP, INPUT_PULLDOWN</h3>
<p>Digital pins can be used as INPUT, INPUT_PULLUP, INPUT_PULLDOWN or OUTPUT. Changing a pin with <code>pinMode()</code> changes the electrical behavior of the pin.</p>
<p>Pins Configured as <code>INPUT</code></p>
<p>The Spark Core&#39;s pins configured as <code>INPUT</code> with <code>pinMode()`` are said to be in a high-impedance state. Pins configured as</code>INPUT` make extremely small demands on the circuit that they are sampling, equivalent to a series resistor of 100 Megohms in front of the pin. This makes them useful for reading a sensor, but not powering an LED.</p>
<p>If you have your pin configured as an <code>INPUT</code>, you will want the pin to have a reference to ground, often accomplished with a pull-down resistor (a resistor going to ground).</p>
<p>Pins Configured as <code>INPUT_PULLUP</code> or <code>INPUT_PULLDOWN</code></p>
<p>The STM32 microcontroller has internal pull-up resistors (resistors that connect to power internally) and pull-down resistors (resistors that connect to ground internally) that you can access. If you prefer to use these instead of external resistors, you can use these argument in <code>pinMode()</code>.</p>
<p>Pins Configured as <code>OUTPUT</code></p>
<p>Pins configured as <code>OUTPUT</code> with `pinMode()`` are said to be in a low-impedance state. This means that they can provide a substantial amount of current to other circuits. STM32 pins can source (provide positive current) or sink (provide negative current) up to 20 mA (milliamps) of current to other devices/circuits. This makes them useful for powering LED&#39;s but useless for reading sensors. Pins configured as outputs can also be damaged or destroyed if short circuited to either ground or 3.3 volt power rails. The amount of current provided by the pin is also not enough to power most relays or motors, and some interface circuitry will be required.</p>
<h3 id="true-false">true | false</h3>
<p>There are two constants used to represent truth and falsity in the Arduino language: true, and false.</p>
<p><code>false</code></p>
<p><code>false</code> is the easier of the two to define. false is defined as 0 (zero).</p>
<p><code>true</code></p>
<p><code>true</code> is often said to be defined as 1, which is correct, but true has a wider definition. Any integer which is non-zero is true, in a Boolean sense. So -1, 2 and -200 are all defined as true, too, in a Boolean sense.</p>
<p>Note that the true and false constants are typed in lowercase unlike <code>HIGH, LOW, INPUT, &amp; OUTPUT.</code></p>

      </div>
    </div>
  </div>


  <!-- Custom -->
  <script src='../assets/js/main.js'></script>

</body>
</html>
